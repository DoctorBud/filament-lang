<html>
<head>
    <style type="text/css">
        #canvas {
            width:1200px;
            height:600px;
        }
    </style>
</head>
<body>
<canvas id="canvas" width="1200" height="600"></canvas>
<script type="module">
    const canvas = document.getElementById('canvas')
    //do 2x dpi
    canvas.width = 1200*2
    canvas.height = 600*2


    //color constants
    const RED = [1, 0, 0]
    const GREEN = [0, 1, 0]
    const BLUE = [0,0,1]
    const BLACK = [0,0,0]
    const MAGENTA = [1,0,1]
    const YELLOW = [1,1,0]
    const WHITE = [1,1,1]

    const ambient = 0.3


    const fov = 45
    const fov_radians = (Math.PI * (fov/2))/180
    const ctx = canvas.getContext('2d')
    let size = 20
    let w = canvas.width/size
    let h = canvas.height/size

    function draw_px(ctx, x, y, c) {
        let col = `rgb(${c[0]*255},${c[1]*255},${c[2]*255})`;
        ctx.fillStyle = col
        ctx.fillRect(x*size,y*size,size*0.9,size*0.9)
    }
    function lerp_vec(t, A, B) {
        return [
            (1-t)*A[0] + (t)*B[0],
            (1-t)*A[1] + (t)*B[1],
            (1-t)*A[2] + (t)*B[2],
        ]
    }

    function len(dir) {
        return Math.sqrt(dir[0]*dir[0]+ dir[1]*dir[1] + dir[2]*dir[2])
    }

    function norm(dir) {
        let l = len(dir)
        return [
            dir[0]/l,
            dir[1]/l,
            dir[2]/l
        ]
    }

    function sub_v(A, B) {
        return [A[0]-B[0],A[1]-B[1],A[2]-B[2]]
    }
    function dot_v(A, B) {
        return A[0]*B[0] + A[1]*B[1] + A[2]*B[2]
    }
    function mul_v(A, B) {
        return [A[0]*B[0],A[1]*B[1],A[2]*B[2]]
    }
    function add_v(A, B) {
        return [A[0]+B[0],A[1]+B[1],A[2]+B[2]]
    }


    function mul_s(A, s) {
        return [A[0]*s, A[1]*s, A[2]*s]
    }
    function sub_s(A, s) {
        return [A[0]-s, A[1]-s, A[2]-s]
    }


    function hit_sphere(cen, rad, ray) {
        let oc = sub_v(ray.origin,cen)
        let a = dot_v(ray.dir, ray.dir)
        let b = 2.0 * dot_v(oc,ray.dir)
        let c = dot_v(oc,oc) - rad*rad
        let discr = b*b - 4*a*c
        if (discr < 0) {
            return -1
        } else {
            return (-b -Math.sqrt(discr))/(2.0*a)
        }
    }

    function point_at_t(A, B, t) {
        //A + t*B
        return add_v(A,mul_s(B,t))
    }

    let spheres = [
        {
            pos:[-1,0,-1],
            rad:0.25,
            color:RED,
        },
        {
            pos:[0,0,-1],
            rad:0.5,
            color:BLUE,
        },
        {
            pos:[1,0,-1],
            rad:0.25,
            color:GREEN,
        },
    ]
    let light = {
        pos:[10,10,0]
    }

    for(let x=0; x<w; x++) {
        for(let y=0; y<h; y++) {
            let u = x/w
            let v = y/h
            let ray = {
                origin:[0,0,0],
                dir:[-2+u*4,1-v*2,-1]
            }

            let list = spheres
            //shoot ray, look for intersection
            let inter = null
            let c = [0,0,0]
            for(let i=0; i<list.length; i++) {
                let sph = list[i]
                let t = hit_sphere(sph.pos, sph.rad, ray)
                //if intersection
                if (t > 0) {
                    inter = { t:t, obj:sph}
                }
            }
            if(inter) {
                c = [0,0,1]
                // shoot ray to light
                let hit_point = point_at_t(ray.origin,ray.dir,inter.t)
                let N = norm(sub_v(hit_point, inter.obj.pos))
                let ray2 = {
                    origin:hit_point,
                    dir:sub_v(light.pos,hit_point)
                }
                let inter2 = null
                for(let j=0; j<list.length; j++) {
                    let sph = list[j]
                    let tt = hit_sphere(sph.pos,sph.rad,ray2)
                    if(tt > 0) {
                        inter2 = {t:tt, obj:sph}
                    }
                }
                // if reach light
                if(!inter2) {
                    //color = ambient * material + diffuse * material
                    let diffuse = dot_v(norm(sub_v(light.pos,hit_point)),N)
                    c = add_v(mul_s(inter.obj.color,ambient),
                        mul_s(inter.obj.color,diffuse))
                } else {
                    //if in shadow, use just ambient
                    c = mul_s(inter.obj.color,ambient)
                }
            } else {
                // color background
                c = WHITE
            }

            draw_px(ctx,x,y,c)
            // ctx.fillStyle = 'black'
            // ctx.font = '16px sans-serif';
            // let t = ray.dir[1]
            // ctx.fillText(t.toFixed(2),x*size+3,y*size+size*0.5)
        }
    }
</script>
</body>
</html>